const MEAN: [f32; 6] = [2.2071579, 0.3158244, -25.365477, -34.083225, 0.4622654, -0.4302501];
const STD: [f32; 6] = [1.0829322, 0.46484333, 243.89526, 228.0317, 0.4985741, 2.3820405];

const W1: [[f32; 6]; 32] = [
    [0.04892852, 0.01787545, 0.41835326, -0.8796744, -0.5294247, 0.01265744],
    [0.10110556, -0.02037014, -0.5656365, -0.641022, 0.07956357, 0.09805533],
    [0.01912177, -0.0183349, -0.8182217, 1.2919985, -0.05731145, -0.00556694],
    [0.37779766, -0.01224655, 0.0056631, 0.7687242, 0.10105554, 1.0205902],
    [-0.03612565, 0.41436982, -0.31336766, 0.01681562, 0.11276007, 0.21953955],
    [-0.0292014, 0.33802903, 0.95207626, -0.2144104, 0.4972893, 0.10248224],
    [-0.17933162, 0.02494843, 0.02846705, 0.04869395, -0.00686422, 0.78251565],
    [-0.036082, -0.08031438, -0.46308023, 0.705734, -0.04118261, 0.1473684],
    [-0.24748471, 0.01132864, -0.16918902, 0.03048099, 0.647557, 0.9124088],
    [0.13967685, 0.40052116, 0.17792864, 0.03995286, -0.01244964, -0.3743262],
    [0.02656581, 0.48802608, 0.5129691, 0.06221629, -0.36052144, 0.3447246],
    [-0.00997827, 0.00678108, -0.01057142, -0.15210146, 0.49450454, -1.0326366],
    [0.2435294, -0.56476367, 0.35106918, -0.19910955, -0.01675929, -0.2676479],
    [0.02799963, 0.00513093, -0.781882, -0.09345718, 0.25410494, 0.19007608],
    [0.09085221, 0.510706, -0.07124753, -0.34616703, -0.17807718, 0.24722123],
    [-0.15296765, -0.00206508, 0.04184695, -0.5484042, -0.6290604, -0.8301172],
    [0.2734216, 0.10740197, 0.51405895, -0.00225644, 0.43114638, 0.34410658],
    [0.07985631, 0.0018956, 0.6478946, -0.40236446, 0.17058124, 0.31716734],
    [0.08617041, 0.01496386, 0.0331827, -1.5937507, 0.1274332, 0.42996794],
    [0.23095295, -0.07441855, 0.47893196, 0.2787444, 0.73584884, -0.1622034],
    [0.22998776, -0.00238366, 0.43438268, 0.07085504, 0.3194257, 0.76937467],
    [0.22552173, -0.0211304, -0.15434213, 0.00300437, -0.19676955, -0.6181776],
    [-0.10284627, -0.49620306, -0.4568505, 0.57040024, 0.21052642, 0.42138252],
    [-0.009865, 0.43766782, -0.35365087, -0.3454229, -0.25405446, -0.06248958],
    [0.03979858, 0.10861576, 0.20797, -1.3514369, -0.13849169, 0.05956792],
    [-0.04914008, 0.08496837, -0.1187434, 0.61922234, 0.19672239, -0.23012148],
    [0.43853644, 0.10778042, -0.3059521, 0.05216942, 0.11590674, 0.47450563],
    [0.2699315, -0.08539873, 0.04102815, 0.5726787, 0.33421543, 0.04973204],
    [0.5035546, -0.01375689, 0.15021057, -0.10318143, 0.44379872, -0.38066256],
    [-0.1746084, 0.41981938, -0.24652249, 0.5568651, 0.43599686, -0.11133575],
    [-0.15680143, 0.15558916, 0.8943791, 0.6684812, 0.22711943, 0.23002331],
    [-0.12092579, -0.35319477, -0.13970186, 0.6276223, 0.5326117, -0.2701976],
];
const B1: [f32; 32] = [
    0.34362787, 0.51429874, -0.47747058, 0.32450202, -0.04050372, 0.11890862,
    -0.13715945, 0.41740814, -0.40154043, -0.17025702, 0.11383659, -0.26044255,
    0.2845477, 0.28114668, 0.26791722, 0.2704251, -0.54473615, 0.35530964,
    0.7342201, -0.14843811, -0.19793366, 0.20974126, -0.07894023, 0.39249766,
    -0.19101816, 0.2122526, 0.1806929, 0.6880135, 0.08973495, 0.08726115,
    0.21914202, 0.15616375,
];
const W2: [[f32; 32]; 1] = [[
    0.41586673, -0.30579713, -0.8268637, 0.50314635, 0.06142725, -0.4827394,
    -0.3332977, 0.44801497, -0.42467263, 0.16464522, -0.25891858, -0.61915636,
    0.15838695, -0.49720374, 0.31211245, 0.64425, 0.4082648, -0.26515582,
    -0.89127034, 0.37807146, 0.47790363, -0.16617146, 0.5864105, 0.24922006,
    0.76071614, 0.38188934, 0.20507684, 0.11679322, 0.1411805, 0.5285492,
    0.37583598, 0.46201125,
]];
const B2: [f32; 1] = [-0.08160271];

fn relu(x: f32) -> f32 {
    if x > 0.0 {
        x
    } else {
        0.0
    }
}

fn sigmoid(x: f32) -> f32 {
    1.0 / (1.0 + (-x).exp())
}

fn linear<const OUT: usize, const IN: usize>(
    input: &[f32; IN], weights: &[[f32; IN]; OUT], bias: &[f32; OUT],
) -> [f32; OUT] {
    let mut out = [0.0; OUT];
    for i in 0..OUT {
        out[i] = bias[i];
        for j in 0..IN {
            out[i] += weights[i][j] * input[j];
        }
    }
    out
}

pub fn predict(mut input: [f32; 6]) -> f32 {
    for i in 0..6 {
        input[i] = (input[i] - MEAN[i]) / STD[i];
    }

    let hidden = linear::<32, 6>(&input, &W1, &B1);
    let mut activated = [0.0; 32];
    for i in 0..32 {
        activated[i] = relu(hidden[i]);
    }

    let output = linear::<1, 32>(&activated, &W2, &B2);
    sigmoid(output[0])
}

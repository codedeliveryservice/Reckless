use crate::{
    evaluate::evaluate,
    movepick::{MovePicker, Stage},
    parameters::PIECE_VALUES,
    tb::{tb_probe, tb_size, GameOutcome},
    thread::{RootMove, ThreadData},
    transposition::{Bound, TtDepth},
    types::{
        is_decisive, is_loss, is_valid, is_win, mate_in, mated_in, tb_loss_in, tb_win_in, ArrayVec, Color, Move, Piece,
        Score, Square, MAX_PLY,
    },
};

pub const FEATURE_DIM: usize = 11;
pub const L1_OUT: usize = 32;
pub const L2_OUT: usize = 16;

pub const SCALER_MEAN: [f32; FEATURE_DIM] = [
    390.5425680857089,
    2.8704152122517685,
    0.4002443735223834,
    0.5898709084140222,
    81.78910692296188,
    -1.6250871057965526,
    0.36528114091888264,
    0.2641843238203727,
    0.15466648423504406,
    0.0,
    333.9869206072427,
];

pub const SCALER_INV_SCALE: [f32; FEATURE_DIM] = [
    1.0 / 1274.0605152335806,  // ≈ 0.0007848921
    1.0 / 2.249418404248543,   // ≈ 0.44455937
    1.0 / 0.489947767609258,   // ≈ 2.0410337
    1.0 / 0.49185690990711567, // ≈ 2.0331116
    1.0 / 91.35156800340785,   // ≈ 0.01094672
    1.0 / 2.6195586845078576,  // ≈ 0.3817437
    1.0 / 0.4815089085431395,  // ≈ 2.0768049
    1.0 / 0.4408979098006538,  // ≈ 2.2680988
    1.0 / 0.3615864528548301,  // ≈ 2.7655904
    1.0 / 1.0,                 // 1
    1.0 / 1283.601083905535,   // ≈ 0.00077905826
];

// --- Layer 1 (32×11) ---
pub const L1_W: [[f32; FEATURE_DIM]; L1_OUT] = [
    [
        -0.2935364246368408,
        -0.15272879600524902,
        -0.057036761194467545,
        -0.33032333850860596,
        0.461248517036438,
        -0.18740929663181305,
        0.012588562443852425,
        0.04095574840903282,
        0.013746779412031174,
        -0.2971036732196808,
        -0.13888274133205414,
    ],
    [
        -0.012728217989206314,
        0.3116694688796997,
        0.025788627564907074,
        -0.21573029458522797,
        -0.14326982200145721,
        0.4800587296485901,
        0.2867096960544586,
        0.0302486140280962,
        0.17714090645313263,
        0.03752385079860687,
        -1.300865888595581,
    ],
    [
        0.1339244246482849,
        0.08280635625123978,
        0.1505039930343628,
        0.0768992155790329,
        -0.08826645463705063,
        -0.5785799026489258,
        -0.051754314452409744,
        -0.25874078273773193,
        -0.3512786626815796,
        -0.03344498574733734,
        -0.07756268978118896,
    ],
    [
        0.03532588109374046,
        0.1566706746816635,
        0.2079075127840042,
        0.2301696538925171,
        -0.2660270929336548,
        -0.15365158021450043,
        -0.1921372264623642,
        -0.35585734248161316,
        0.3669451177120209,
        -0.007078250870108604,
        -0.0365578792989254,
    ],
    [
        0.03123200125992298,
        -0.7543447017669678,
        0.027220826596021652,
        0.025089092552661896,
        -0.009937779977917671,
        0.22351902723312378,
        -0.4163607954978943,
        0.15936006605625153,
        0.040034011006355286,
        0.27051442861557007,
        0.02873617596924305,
    ],
    [
        -1.254540205001831,
        0.04649772122502327,
        -0.0022704291623085737,
        0.033774904906749725,
        -0.07677524536848068,
        0.024103088304400444,
        -0.04302845895290375,
        0.04316267371177673,
        0.018288368359208107,
        0.28821057081222534,
        -0.6310707330703735,
    ],
    [
        -1.0128062963485718,
        -0.1627824455499649,
        -0.006929988972842693,
        0.03246038034558296,
        0.012871116399765015,
        -0.17598463594913483,
        0.07839704304933548,
        -0.1711776703596115,
        -0.2621779441833496,
        0.2573704719543457,
        0.15992142260074615,
    ],
    [
        0.40995579957962036,
        0.472158282995224,
        0.01841937191784382,
        -0.1587287038564682,
        -0.23683473467826843,
        0.18350286781787872,
        -0.004830386955291033,
        -0.12496677786111832,
        -0.48116806149482727,
        0.07813432812690735,
        0.09176025539636612,
    ],
    [
        -0.10335837304592133,
        -0.6179966330528259,
        0.00202289130538702,
        -0.0393773689866066,
        0.05911119282245636,
        0.34007155895233154,
        0.45405200123786926,
        -0.4668786823749542,
        -0.16795910894870758,
        0.15199831128120422,
        0.09373059868812561,
    ],
    [
        -0.7208414077758789,
        -0.42967328429222107,
        0.011404731310904026,
        -0.02100195363163948,
        -0.07070710510015488,
        0.17550328373908997,
        -0.1388402134180069,
        0.3469516336917877,
        -0.5264975428581238,
        -0.21286985278129578,
        0.5081785321235657,
    ],
    [
        -0.010023978538811207,
        -0.019880756735801697,
        -0.2633783221244812,
        -0.22159278392791748,
        0.011569942347705364,
        0.10834629833698273,
        -0.14794446527957916,
        -0.08473820984363556,
        0.06955499202013016,
        0.04086674749851227,
        -0.7325556874275208,
    ],
    [
        -0.22618186473846436,
        -0.2882131040096283,
        0.07721150666475296,
        -0.1363576501607895,
        0.13618320226669312,
        -0.6581761837005615,
        0.2951541841030121,
        0.21064674854278564,
        0.035218264907598495,
        0.28228724002838135,
        0.17549364268779755,
    ],
    [
        0.5490385890007019,
        0.26443588733673096,
        -0.08684111386537552,
        -0.0034472078550606966,
        -0.11087355762720108,
        0.3216688632965088,
        0.0563688799738884,
        -0.36902305483818054,
        -0.2625414729118347,
        0.138240784406662,
        -0.5611798763275146,
    ],
    [
        0.14707519114017487,
        -0.4255554676055908,
        -0.46164336800575256,
        -0.05612971633672714,
        0.1033715233206749,
        -0.37164703011512756,
        0.023519150912761688,
        -0.05415051430463791,
        -0.25927308201789856,
        -0.25545692443847656,
        0.2571062743663788,
    ],
    [
        0.6238376498222351,
        -0.40107905864715576,
        0.001223157742060721,
        -0.2737288475036621,
        0.021646736189723015,
        0.028980853036046028,
        0.20980843901634216,
        -0.3413280248641968,
        -0.07834206521511078,
        -0.055502235889434814,
        -0.6438177227973938,
    ],
    [
        -0.7675045728683472,
        -0.1135287806391716,
        0.10261350125074387,
        -0.14443373680114746,
        -0.07111416757106781,
        -0.08751028776168823,
        0.4090472459793091,
        0.02633841522037983,
        0.047024164348840714,
        -0.09151284396648407,
        0.4120185971260071,
    ],
    [
        -0.783362865447998,
        0.42295196652412415,
        0.05724585801362991,
        0.08213960379362106,
        -0.02601003833115101,
        0.33830443024635315,
        -0.061718281358480453,
        0.04613952711224556,
        0.11836190521717072,
        -0.20468053221702576,
        -0.786570131778717,
    ],
    [
        0.3956809937953949,
        0.044590119272470474,
        0.3118021488189697,
        0.1693076193332672,
        -0.06363605707883835,
        0.08290011435747147,
        0.2532636225223541,
        -0.29131248593330383,
        -0.014448467642068863,
        -0.07565285265445709,
        -0.19448842108249664,
    ],
    [
        0.23933391273021698,
        -0.04949485883116722,
        0.29799777269363403,
        0.4949777126312256,
        0.02440628409385681,
        0.5337623953819275,
        0.32963883876800537,
        0.10538432747125626,
        -0.04598786309361458,
        -0.22804343700408936,
        0.06530601531267166,
    ],
    [
        0.11652207374572754,
        -0.36096084117889404,
        -0.06074625253677368,
        0.3089531660079956,
        -0.020581332966685295,
        -0.31557947397232056,
        0.267748087644577,
        -0.4781545400619507,
        -0.3914375901222229,
        -0.272987961769104,
        -0.19890299439430237,
    ],
    [
        -0.06802187860012054,
        0.11297770589590073,
        0.0021986495703458786,
        -0.10973294824361801,
        -0.13328085839748383,
        0.07540085166692734,
        0.27073198556900024,
        -0.2038036584854126,
        -0.06277294456958771,
        -0.12295293807983398,
        -0.45959168672561646,
    ],
    [
        -1.2895188331604004,
        -0.0023862121161073446,
        0.0031904331408441067,
        0.0038822670467197895,
        0.0005923990975134075,
        0.015820017084479332,
        -0.0033571706153452396,
        0.06900680810213089,
        -0.011480351909995079,
        -0.18373268842697144,
        -0.4585530459880829,
    ],
    [
        0.13737571239471436,
        -0.48391881585121155,
        0.0032624169252812862,
        0.2827680706977844,
        -0.13432681560516357,
        0.04206455871462822,
        0.26373010873794556,
        -0.24449504911899567,
        -0.1521206647157669,
        -0.1982022225856781,
        -0.23122024536132812,
    ],
    [
        -0.221851646900177,
        -0.05567639693617821,
        -0.0028113729786127806,
        0.01669766567647457,
        -0.014244339428842068,
        0.72053462266922,
        -0.3016952872276306,
        0.11498595029115677,
        0.02734583429992199,
        -0.06167462468147278,
        0.3321496248245239,
    ],
    [
        -0.1659715473651886,
        0.27637526392936707,
        -0.15383069217205048,
        0.36441752314567566,
        0.08624403923749924,
        -0.8526107668876648,
        0.272567480802536,
        0.2759399712085724,
        0.08961641788482666,
        0.13082745671272278,
        0.22587579488754272,
    ],
    [
        -0.012813117355108261,
        0.20194287598133087,
        0.03514750674366951,
        -0.3106797933578491,
        0.03282489627599716,
        -0.46057775616645813,
        -0.14224879443645477,
        0.7999943494796753,
        -0.023330260068178177,
        -0.2861012816429138,
        0.002920580329373479,
    ],
    [
        0.2399417608976364,
        -0.3274816870689392,
        0.013818638399243355,
        0.3850398063659668,
        -0.09270625561475754,
        -0.2533734142780304,
        0.10770642757415771,
        -0.006652698386460543,
        0.14863377809524536,
        -0.08622632920742035,
        -0.028340615332126617,
    ],
    [
        0.19102469086647034,
        0.3374699354171753,
        -0.044105954468250275,
        0.32998132705688477,
        -0.05046955123543739,
        0.13571646809577942,
        -0.15309013426303864,
        0.09124511480331421,
        -0.3808642029762268,
        0.2649539113044739,
        0.4303951561450958,
    ],
    [
        -0.9685212969779968,
        -0.1337275505065918,
        -0.0006765270372852683,
        -0.4006977379322052,
        -0.004832848906517029,
        -0.03056299313902855,
        -0.07699734717607498,
        -0.20542548596858978,
        0.10791580379009247,
        0.18065589666366577,
        -0.5571601986885071,
    ],
    [
        0.05751585587859154,
        0.10356037318706512,
        0.0033857496455311775,
        0.5494431257247925,
        0.057290516793727875,
        -0.012748229317367077,
        -0.13868963718414307,
        -0.5383217334747314,
        -0.44472309947013855,
        0.27556002140045166,
        -0.24017325043678284,
    ],
    [
        0.18861036002635956,
        0.22697485983371735,
        -0.32975253462791443,
        -0.44582879543304443,
        -0.11749667674303055,
        0.03619558364152908,
        -0.11678089946508408,
        -0.053105756640434265,
        -0.1798500269651413,
        0.14070230722427368,
        0.3123146891593933,
    ],
    [
        0.46972593665122986,
        0.3613998591899872,
        0.023377958685159683,
        0.15385913848876953,
        0.3054434359073639,
        -0.07624053955078125,
        0.3181767165660858,
        -0.21412917971611023,
        0.05654820427298546,
        0.1787387728691101,
        -0.1363741010427475,
    ],
];
pub const L1_B: [f32; L1_OUT] = [
    -0.1252569854259491,
    0.6010251641273499,
    0.39383888244628906,
    0.3091159462928772,
    0.05998486280441284,
    -0.45553016662597656,
    0.3155732750892639,
    0.2002875953912735,
    -0.2543174922466278,
    0.1893945336341858,
    0.38957059383392334,
    -0.21895113587379456,
    0.25333473086357117,
    0.1845744103193283,
    -0.20569546520709991,
    0.0906601995229721,
    -0.11912283301353455,
    0.15306894481182098,
    -0.09022657573223114,
    0.37731829285621643,
    -0.5481258034706116,
    -0.37437698245048523,
    0.02749677002429962,
    0.0018274986650794744,
    0.07970508188009262,
    0.3246906101703644,
    -0.321248322725296,
    -0.08697265386581421,
    -0.2866334915161133,
    -0.1477702111005783,
    -0.3770393431186676,
    -0.002388200955465436,
];

// --- Layer 2 (16×32) ---
pub const L2_W: [[f32; L1_OUT]; L2_OUT] = [
    [
        -0.08275692909955978,
        0.5110890865325928,
        0.19678819179534912,
        0.1689760833978653,
        0.07154633849859238,
        0.4288775622844696,
        -0.261659175157547,
        -0.03853459656238556,
        -0.0797596201300621,
        -0.3617721498012543,
        0.10112836211919785,
        -0.39418333768844604,
        0.1984100639820099,
        -0.17921295762062073,
        0.39053773880004883,
        -0.3560832440853119,
        0.3790360391139984,
        0.2280585765838623,
        0.18100525438785553,
        0.13966621458530426,
        -0.17356853187084198,
        0.4060823917388916,
        0.01800713688135147,
        0.06514228880405426,
        0.08116862177848816,
        -0.358396053314209,
        0.08200902491807938,
        -0.08414212614297867,
        0.2754514217376709,
        0.4593326449394226,
        0.12664605677127838,
        0.20291626453399658,
    ],
    [
        0.420352965593338,
        0.11799570918083191,
        -0.21031993627548218,
        0.06818073242902756,
        -0.0914934054017067,
        0.27683931589126587,
        0.3884512484073639,
        0.26498091220855713,
        0.2048358917236328,
        0.016634752973914146,
        0.2682855725288391,
        0.11836816370487213,
        -0.4458155035972595,
        0.2877933084964752,
        0.04946848005056381,
        0.1488017737865448,
        0.3386722505092621,
        -0.12670893967151642,
        -0.10144779086112976,
        0.03698744624853134,
        0.036121223121881485,
        0.15572109818458557,
        0.19491082429885864,
        -0.07312922179698944,
        0.15451881289482117,
        -0.007951692678034306,
        0.046463701874017715,
        0.28222835063934326,
        0.0015601430786773562,
        -0.32108983397483826,
        0.17884132266044617,
        0.1710158735513687,
    ],
    [
        0.1746637225151062,
        0.2512896955013275,
        -0.01711886376142502,
        0.19165271520614624,
        0.3118560314178467,
        -0.831091582775116,
        -0.44139689207077026,
        0.15551072359085083,
        -0.032245997339487076,
        -0.4285701811313629,
        0.12182138115167618,
        -0.15648137032985687,
        0.35745036602020264,
        -0.07829682528972626,
        0.6310563087463379,
        -0.37262773513793945,
        -0.5034105777740479,
        0.04086493328213692,
        -0.019408291205763817,
        0.10403157770633698,
        -0.13752096891403198,
        -0.975602388381958,
        0.13890451192855835,
        -0.40259528160095215,
        -0.105531245470047,
        -0.0009184543159790337,
        0.22391445934772491,
        -0.1839328408241272,
        -0.11646007001399994,
        0.0979495570063591,
        -0.1649663746356964,
        0.20113684237003326,
    ],
    [
        -0.21265806257724762,
        0.28150656819343567,
        0.17670656740665436,
        0.022262485697865486,
        0.3547719120979309,
        -0.9984342455863953,
        -0.4971020817756653,
        0.1248311996459961,
        0.11545076966285706,
        -0.3552725911140442,
        0.07329221069812775,
        -0.2737334370613098,
        0.24560877680778503,
        0.20218895375728607,
        0.7026192545890808,
        -0.30614855885505676,
        -0.29494479298591614,
        0.30695411562919617,
        0.06200328469276428,
        0.13678303360939026,
        -0.02661368064582348,
        -0.7156558036804199,
        0.031540676951408386,
        -0.44032570719718933,
        -0.10470332205295563,
        -0.16867215931415558,
        0.03486599400639534,
        -0.048159774392843246,
        -0.2894737720489502,
        0.0818842425942421,
        -0.16748249530792236,
        0.3034035265445709,
    ],
    [
        -0.0703696757555008,
        0.38156118988990784,
        0.18332529067993164,
        0.15865877270698547,
        0.19483360648155212,
        -1.2349598407745361,
        -0.6299920678138733,
        -0.024345651268959045,
        -0.05276329442858696,
        0.18152938783168793,
        0.3490329682826996,
        0.02277962490916252,
        0.10744054615497589,
        -0.04413207992911339,
        0.5500690340995789,
        -0.2424280047416687,
        -0.8403739929199219,
        0.17399193346500397,
        0.015329092741012573,
        0.11563102155923843,
        0.1886364072561264,
        -1.2182488441467285,
        0.20341843366622925,
        -0.25096365809440613,
        -0.10765830427408218,
        0.6415872573852539,
        0.07900525629520416,
        -0.1144152283668518,
        -0.7399343252182007,
        -0.027690580114722252,
        -0.0853462740778923,
        0.010208596475422382,
    ],
    [
        -0.05057759955525398,
        -0.16240108013153076,
        -0.11406099796295166,
        -0.1540563702583313,
        -0.024107232689857483,
        -0.16337528824806213,
        -0.05580352619290352,
        -0.11259017884731293,
        -0.15239757299423218,
        -0.03919927775859833,
        -0.19812539219856262,
        0.026717185974121094,
        -0.09119218587875366,
        -0.17266462743282318,
        -0.007031644228845835,
        -0.1214064508676529,
        0.01414574310183525,
        -0.13950951397418976,
        0.028580699115991592,
        -0.11725620925426483,
        -0.017825432121753693,
        -0.12051495909690857,
        -0.10113265365362167,
        -0.17005571722984314,
        -0.11407672613859177,
        -0.0015562307089567184,
        -0.09685029089450836,
        -0.14046630263328552,
        -0.07566222548484802,
        -0.003907185047864914,
        0.09368772804737091,
        0.07300404459238052,
    ],
    [
        -0.1316528171300888,
        0.2635997235774994,
        0.0988694280385971,
        0.09471911936998367,
        0.10649213939905167,
        -1.000007152557373,
        -0.4072422981262207,
        -0.1617860347032547,
        -0.18667080998420715,
        0.03350251913070679,
        0.1216522753238678,
        -0.237473726272583,
        0.3075583577156067,
        0.07607635110616684,
        0.5689818859100342,
        -0.364646852016449,
        -0.7115658521652222,
        0.22471581399440765,
        -0.08768368512392044,
        0.12071994692087173,
        0.19326478242874146,
        -0.7539476752281189,
        0.22517448663711548,
        -0.5099638104438782,
        0.020651185885071754,
        0.18092690408229828,
        0.15379029512405396,
        -0.08637361973524094,
        -0.11757783591747284,
        -0.15829341113567352,
        -0.056529223918914795,
        -0.09439635276794434,
    ],
    [
        0.0038383323699235916,
        0.1571035236120224,
        0.06972284615039825,
        -0.1505197137594223,
        0.08307641744613647,
        0.04506881907582283,
        -0.020623577758669853,
        0.13342535495758057,
        0.48659026622772217,
        0.20786429941654205,
        0.1937052309513092,
        -0.5325820446014404,
        -0.30661168694496155,
        0.04258342832326889,
        -0.6408273577690125,
        -0.11528774350881577,
        0.22410990297794342,
        0.16218195855617523,
        0.17319925129413605,
        -0.48980680108070374,
        -0.08926738053560257,
        0.13540148735046387,
        -0.13945059478282928,
        0.1906832456588745,
        -0.5545646548271179,
        0.2581440210342407,
        -0.054101087152957916,
        -0.01778249815106392,
        0.035023849457502365,
        0.003111785277724266,
        0.10659661889076233,
        -0.07571100443601608,
    ],
    [
        -0.03214734420180321,
        0.43420952558517456,
        -0.11535269021987915,
        0.13293692469596863,
        0.4403417408466339,
        -1.0612363815307617,
        -0.7494586706161499,
        0.13181373476982117,
        -0.2231752574443817,
        -0.381460964679718,
        0.23996680974960327,
        -0.00020505084830801934,
        0.5261690616607666,
        0.0762951672077179,
        0.7181365489959717,
        -0.2909517288208008,
        -0.6733763217926025,
        0.22641323506832123,
        0.03774533048272133,
        0.07154009491205215,
        -0.02327798679471016,
        -1.14982008934021,
        0.20495890080928802,
        -0.5863938331604004,
        -0.061639752238988876,
        0.12359583377838135,
        -0.0009560288744978607,
        -0.23741425573825836,
        -0.31175553798675537,
        0.07783100008964539,
        -0.2922643721103668,
        0.15291890501976013,
    ],
    [
        0.008839371614158154,
        0.07750637829303741,
        0.00881414208561182,
        0.06696855276823044,
        -0.22973573207855225,
        0.07256314158439636,
        0.24102818965911865,
        0.2294430136680603,
        -0.009602357633411884,
        -0.06418255716562271,
        0.13011309504508972,
        -0.32156601548194885,
        0.02370736189186573,
        0.3235855996608734,
        -0.222898468375206,
        0.019358424469828606,
        0.3808209300041199,
        0.03683089837431908,
        0.23666422069072723,
        -0.16808009147644043,
        0.026317663490772247,
        0.16915981471538544,
        -0.09233348071575165,
        0.0569147989153862,
        -0.2900252342224121,
        0.12555953860282898,
        -0.0477273166179657,
        0.24218426644802094,
        -0.13586585223674774,
        -0.30842530727386475,
        0.3434343636035919,
        0.04544215649366379,
    ],
    [
        0.1951899528503418,
        0.045880675315856934,
        -0.1716069132089615,
        0.24003925919532776,
        0.19078797101974487,
        0.16540831327438354,
        0.061268966645002365,
        0.24257047474384308,
        0.25094255805015564,
        0.17875723540782928,
        0.20168104767799377,
        0.07986776530742645,
        -0.4383581280708313,
        0.000304240093100816,
        0.3117551803588867,
        0.35216113924980164,
        0.10068076103925705,
        -0.16855038702487946,
        -0.7787368297576904,
        -0.43428835272789,
        0.02140258625149727,
        0.0768565908074379,
        -0.2132415771484375,
        0.03740115463733673,
        0.08750145137310028,
        -0.021922269836068153,
        0.12431732565164566,
        0.15890081226825714,
        0.036507513374090195,
        -0.8027072548866272,
        0.24834135174751282,
        0.04814756289124489,
    ],
    [
        -0.17407798767089844,
        -0.06853093206882477,
        -0.0997706726193428,
        0.10429728031158447,
        -0.12506958842277527,
        -0.14761531352996826,
        -0.20367497205734253,
        -0.16501280665397644,
        0.10165698081254959,
        -0.05666676536202431,
        0.08701679110527039,
        0.10988979041576385,
        0.10610979795455933,
        -0.09469612687826157,
        0.009724033065140247,
        -0.16859449446201324,
        0.028224486857652664,
        -0.03464501351118088,
        -0.03128300607204437,
        0.04396127909421921,
        -0.1470516473054886,
        0.018847551196813583,
        0.031675927340984344,
        -0.12265694886445999,
        -0.047930676490068436,
        0.04900659993290901,
        -0.1110692247748375,
        -0.1794506013393402,
        -0.10837836563587189,
        -0.17332002520561218,
        -0.22525125741958618,
        0.0330844521522522,
    ],
    [
        0.2765178084373474,
        0.011804327368736267,
        -0.082677461206913,
        -0.16082407534122467,
        -0.03500669449567795,
        0.29451870918273926,
        0.20697619020938873,
        0.08969902247190475,
        0.3206755816936493,
        0.11198342591524124,
        0.27487099170684814,
        -0.0056708683259785175,
        -0.20076893270015717,
        0.2769884467124939,
        -0.14220161736011505,
        0.1172923743724823,
        0.09556224942207336,
        0.08475758135318756,
        -0.2683596611022949,
        0.02419632486999035,
        0.18129147589206696,
        0.12055785208940506,
        -0.04871707409620285,
        0.1138579398393631,
        0.19788500666618347,
        -0.0528702586889267,
        0.17227084934711456,
        0.07994183152914047,
        0.192714124917984,
        -0.5051426291465759,
        0.11725344508886337,
        0.006026812829077244,
    ],
    [
        0.17593076825141907,
        0.05336950346827507,
        -0.5294163227081299,
        -0.16472044587135315,
        0.17289288341999054,
        0.15951259434223175,
        0.28141096234321594,
        0.0062028937973082066,
        0.34806540608406067,
        0.08966702967882156,
        0.15409502387046814,
        -0.13439784944057465,
        -0.335311621427536,
        0.3468151092529297,
        -0.657253623008728,
        0.0888068675994873,
        0.07488875091075897,
        0.16618749499320984,
        0.1091613918542862,
        -0.27556267380714417,
        -0.15515093505382538,
        0.057790353894233704,
        0.06397215276956558,
        0.31024444103240967,
        -1.1436878442764282,
        -0.18301154673099518,
        -0.0144273042678833,
        0.12450849264860153,
        0.13233882188796997,
        -0.21966393291950226,
        0.0405210480093956,
        -0.17184393107891083,
    ],
    [
        0.05101319029927254,
        0.23133911192417145,
        -0.24803976714611053,
        0.15638726949691772,
        0.05379723384976387,
        0.16631494462490082,
        -0.04934987053275108,
        0.20750422775745392,
        0.1601516753435135,
        0.10890404880046844,
        -0.02223321422934532,
        -0.4593983590602875,
        -0.08177700638771057,
        0.0736989751458168,
        -0.29920971393585205,
        0.13749033212661743,
        -0.007686026394367218,
        -0.0909365862607956,
        -0.1026061400771141,
        -0.5003947019577026,
        -0.12145328521728516,
        0.09864728152751923,
        -0.3340819180011749,
        0.14574503898620605,
        -0.15913026034832,
        0.22342133522033691,
        0.01583588309586048,
        0.28094756603240967,
        0.1929878443479538,
        -0.5303856730461121,
        0.29671505093574524,
        0.11683489382266998,
    ],
    [
        0.18909475207328796,
        0.32827305793762207,
        -0.003983106929808855,
        -0.17180293798446655,
        0.41847553849220276,
        -0.9708048701286316,
        -0.5430583953857422,
        0.09302084892988205,
        -0.2667768895626068,
        -0.11843279749155045,
        -0.0677533820271492,
        -0.08831501752138138,
        0.2297467291355133,
        -0.038572199642658234,
        0.5237575173377991,
        -0.14108529686927795,
        -0.40248915553092957,
        0.024022266268730164,
        0.24454952776432037,
        0.16567537188529968,
        -0.12965542078018188,
        -0.41419410705566406,
        0.2094191461801529,
        0.03141232952475548,
        -0.1986658275127411,
        -0.05893104150891304,
        -0.08009389042854309,
        -0.25761109590530396,
        -0.22196681797504425,
        0.12723177671432495,
        -0.10657992213964462,
        0.21784336864948273,
    ],
];
pub const L2_B: [f32; L2_OUT] = [
    -0.22493235766887665,
    0.026578238233923912,
    0.12231943756341934,
    -0.002635119715705514,
    0.41616231203079224,
    -0.009602820500731468,
    0.32218238711357117,
    0.025117753073573112,
    0.1940378099679947,
    -0.013353023678064346,
    0.24344317615032196,
    -0.22771605849266052,
    0.28521162271499634,
    0.12056590616703033,
    0.253917396068573,
    0.17026549577713013,
];

pub const L3_W: [f32; L2_OUT] = [
    0.4751409590244293,
    -0.33543768525123596,
    0.5383983850479126,
    0.8557662963867188,
    0.8747825622558594,
    -0.0190897174179554,
    0.468761682510376,
    -0.41560083627700806,
    0.825905978679657,
    -0.36342665553092957,
    -0.31488507986068726,
    -0.1125912219285965,
    -0.3241623640060425,
    -0.2881876528263092,
    -0.3898966908454895,
    0.6101511716842651,
];
pub const L3_B: f32 = 0.015120734460651875;

pub const TEMPERATURE: f32 = 1.0219297781586647;

pub const THRESH_1: f32 = 0.7039687633514404;
pub const THRESH_2: f32 = 0.7409941554069519;
pub const THRESH_3: f32 = 0.7585213780403137;
pub const THRESH_4PLUS: f32 = 0.7053482532501221;
pub const THRESH_DEFAULT: f32 = 0.7039687633514404;

pub fn rfp_threshold_for_depth(d: i32) -> f32 {
    match d {
        1 => THRESH_1,
        2 => THRESH_2,
        3 => THRESH_3,
        d if d >= 4 => THRESH_4PLUS,
        _ => THRESH_DEFAULT,
    }
}

fn relu_scalar(x: f32) -> f32 {
    if x > 0.0 {
        x
    } else {
        0.0
    }
}

pub fn predict_prob(x_in: [f32; FEATURE_DIM]) -> f32 {
    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
    {
        if std::is_x86_feature_detected!("avx2") && std::is_x86_feature_detected!("fma") {
            unsafe {
                return predict_prob_avx2(x_in);
            }
        }
    }
    predict_prob_scalar(x_in)
}

pub fn predict_prob_scalar(mut x: [f32; FEATURE_DIM]) -> f32 {
    for i in 0..FEATURE_DIM {
        x[i] = (x[i] - SCALER_MEAN[i]) * SCALER_INV_SCALE[i];
    }
    let mut h1 = [0f32; L1_OUT];
    for o in 0..L1_OUT {
        let mut z = L1_B[o];
        for j in 0..FEATURE_DIM {
            z += L1_W[o][j] * x[j];
        }
        h1[o] = relu_scalar(z);
    }
    let mut h2 = [0f32; L2_OUT];
    for o in 0..L2_OUT {
        let mut z = L2_B[o];
        for j in 0..L1_OUT {
            z += L2_W[o][j] * h1[j];
        }
        h2[o] = relu_scalar(z);
    }
    let mut z = L3_B;
    for i in 0..L2_OUT {
        z += L3_W[i] * h2[i];
    }
    let zt = z / TEMPERATURE;
    1.0 / (1.0 + (-zt).exp())
}

#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
#[target_feature(enable = "avx2,fma")]
unsafe fn predict_prob_avx2(mut x: [f32; FEATURE_DIM]) -> f32 {
    use std::arch::x86_64::*;
    unsafe fn hsum256_ps(v: __m256) -> f32 {
        let hi = _mm256_extractf128_ps(v, 1);
        let lo = _mm256_castps256_ps128(v);
        let sum128 = _mm_add_ps(lo, hi);
        let shuf = _mm_movehdup_ps(sum128);
        let sums = _mm_add_ps(sum128, shuf);
        let shuf2 = _mm_movehl_ps(shuf, sums);
        let sum = _mm_add_ss(sums, shuf2);
        _mm_cvtss_f32(sum)
    }
    let xv0 = _mm256_loadu_ps(x.as_ptr());
    let mean0 = _mm256_loadu_ps(SCALER_MEAN.as_ptr());
    let inv0 = _mm256_loadu_ps(SCALER_INV_SCALE.as_ptr());
    let std0 = _mm256_mul_ps(_mm256_sub_ps(xv0, mean0), inv0);
    _mm256_storeu_ps(x.as_mut_ptr(), std0);
    for i in 8..FEATURE_DIM {
        x[i] = (x[i] - SCALER_MEAN[i]) * SCALER_INV_SCALE[i];
    }
    let mut h1 = [0f32; L1_OUT];
    let x0 = _mm256_loadu_ps(x.as_ptr());
    for o in 0..L1_OUT {
        let w0 = _mm256_loadu_ps(L1_W[o].as_ptr());
        let acc = _mm256_fmadd_ps(w0, x0, _mm256_setzero_ps());
        let mut z = hsum256_ps(acc) + L1_B[o];
        z += L1_W[o][8] * x[8] + L1_W[o][9] * x[9] + L1_W[o][10] * x[10];
        h1[o] = if z > 0.0 { z } else { 0.0 };
    }
    let mut h2 = [0f32; L2_OUT];
    for o in 0..L2_OUT {
        let mut acc = _mm256_setzero_ps();
        let w00 = _mm256_loadu_ps(L2_W[o].as_ptr());
        let x00 = _mm256_loadu_ps(h1.as_ptr());
        acc = _mm256_fmadd_ps(w00, x00, acc);
        let w01 = _mm256_loadu_ps(L2_W[o].as_ptr().add(8));
        let x01 = _mm256_loadu_ps(h1.as_ptr().add(8));
        acc = _mm256_fmadd_ps(w01, x01, acc);
        let w02 = _mm256_loadu_ps(L2_W[o].as_ptr().add(16));
        let x02 = _mm256_loadu_ps(h1.as_ptr().add(16));
        acc = _mm256_fmadd_ps(w02, x02, acc);
        let w03 = _mm256_loadu_ps(L2_W[o].as_ptr().add(24));
        let x03 = _mm256_loadu_ps(h1.as_ptr().add(24));
        acc = _mm256_fmadd_ps(w03, x03, acc);
        let z = hsum256_ps(acc) + L2_B[o];
        h2[o] = if z > 0.0 { z } else { 0.0 };
    }
    let mut acc = _mm256_setzero_ps();
    let w0 = _mm256_loadu_ps(L3_W.as_ptr());
    let xh0 = _mm256_loadu_ps(h2.as_ptr());
    acc = _mm256_fmadd_ps(w0, xh0, acc);
    let w1 = _mm256_loadu_ps(L3_W.as_ptr().add(8));
    let xh1 = _mm256_loadu_ps(h2.as_ptr().add(8));
    acc = _mm256_fmadd_ps(w1, xh1, acc);
    let z = hsum256_ps(acc) + L3_B;
    let zt = z / TEMPERATURE;
    1.0 / (1.0 + (-zt).exp())
}

#[allow(unused_imports)]
use crate::misc::{dbg_hit, dbg_stats};

#[derive(Copy, Clone, Eq, PartialEq)]
pub enum Report {
    None,
    Minimal,
    Full,
}

trait NodeType {
    const PV: bool;
    const ROOT: bool;
}

struct Root;
impl NodeType for Root {
    const PV: bool = true;
    const ROOT: bool = true;
}

struct PV;
impl NodeType for PV {
    const PV: bool = true;
    const ROOT: bool = false;
}

struct NonPV;
impl NodeType for NonPV {
    const PV: bool = false;
    const ROOT: bool = false;
}

pub fn start(td: &mut ThreadData, report: Report) {
    td.completed_depth = 0;
    td.stopped = false;

    td.pv.clear(0);
    td.nodes.clear();
    td.tb_hits.clear();

    td.nnue.full_refresh(&td.board);

    td.root_moves = td
        .board
        .generate_all_moves()
        .iter()
        .filter(|v| td.board.is_legal(v.mv))
        .map(|v| RootMove {
            mv: v.mv,
            score: -Score::INFINITE,
            display_score: -Score::INFINITE,
            lowerbound: false,
            upperbound: false,
            sel_depth: 0,
            nodes: 0,
        })
        .collect();

    let mut average = Score::NONE;
    let mut last_move = Move::NULL;

    let mut eval_stability = 0;
    let mut pv_stability = 0;

    // Iterative Deepening
    for depth in 1..MAX_PLY as i32 {
        td.sel_depth = 0;
        td.root_depth = depth;

        let mut alpha = -Score::INFINITE;
        let mut beta = Score::INFINITE;

        let mut delta = 12;
        let mut reduction = 0;

        // Aspiration Windows
        if depth >= 2 {
            delta += average * average / 26614;

            alpha = (average - delta).max(-Score::INFINITE);
            beta = (average + delta).min(Score::INFINITE);

            td.optimism[td.board.side_to_move()] = 118 * average / (average.abs() + 237);
            td.optimism[!td.board.side_to_move()] = -td.optimism[td.board.side_to_move()];
        }

        loop {
            td.stack = Default::default();
            td.root_delta = beta - alpha;

            // Root Search
            let score = search::<Root>(td, alpha, beta, (depth - reduction).max(1), false);

            td.root_moves.sort_by(|a, b| b.score.cmp(&a.score));

            if td.stopped {
                break;
            }

            match score {
                s if s <= alpha => {
                    beta = (alpha + beta) / 2;
                    alpha = (score - delta).max(-Score::INFINITE);
                    reduction = 0;
                }
                s if s >= beta => {
                    beta = (score + delta).min(Score::INFINITE);
                    reduction += 1;
                }
                _ => {
                    average = if average == Score::NONE { score } else { (average + score) / 2 };
                    break;
                }
            }

            if report == Report::Full && td.nodes.global() > 10_000_000 {
                td.print_uci_info(depth);
            }

            delta += delta * (38 + 15 * reduction) / 128;
        }

        if td.stopped {
            break;
        }

        td.nodes.flush();
        td.tb_hits.flush();
        td.completed_depth = depth;

        if last_move == td.pv.best_move() {
            pv_stability += 1;
        } else {
            pv_stability = 0;
            last_move = td.pv.best_move();
        }

        if (td.root_moves[0].score - average).abs() < 12 {
            eval_stability += 1;
        } else {
            eval_stability = 0;
        }

        let multiplier = || {
            let nodes_factor = 2.15 - 1.5 * (td.root_moves[0].nodes as f32 / td.nodes.local() as f32);

            let pv_stability = 1.25 - 0.05 * pv_stability.min(8) as f32;

            let eval_stability = 1.2 - 0.04 * eval_stability.min(8) as f32;

            let score_trend =
                (800 + 20 * (td.previous_best_score - td.root_moves[0].score)).clamp(750, 1500) as f32 / 1000.0;

            nodes_factor * pv_stability * eval_stability * score_trend
        };

        if td.time_manager.soft_limit(td, multiplier) {
            break;
        }

        if report == Report::Full {
            td.print_uci_info(depth);
        }
    }

    if report != Report::None {
        td.print_uci_info(td.root_depth);
    }

    td.previous_best_score = td.root_moves[0].score;
}

fn search<NODE: NodeType>(td: &mut ThreadData, mut alpha: i32, mut beta: i32, depth: i32, cut_node: bool) -> i32 {
    debug_assert!(td.ply <= MAX_PLY);
    debug_assert!(-Score::INFINITE <= alpha && alpha < beta && beta <= Score::INFINITE);

    let in_check = td.board.in_check();
    let excluded = td.stack[td.ply].excluded.is_some();

    if NODE::PV {
        td.pv.clear(td.ply);
    }

    if td.stopped {
        return Score::ZERO;
    }

    // Qsearch Dive
    if depth <= 0 {
        return qsearch::<NODE>(td, alpha, beta);
    }

    if !NODE::ROOT && alpha < Score::ZERO && td.board.upcoming_repetition(td.ply) {
        alpha = Score::ZERO;
        if alpha >= beta {
            return alpha;
        }
    }

    if NODE::PV {
        td.sel_depth = td.sel_depth.max(td.ply as i32);
    }

    if td.time_manager.check_time(td) {
        td.stopped = true;
        return Score::ZERO;
    }

    if !NODE::ROOT {
        if td.board.is_draw(td.ply) {
            return Score::DRAW;
        }

        if td.ply >= MAX_PLY - 1 {
            return if in_check { Score::DRAW } else { evaluate(td) };
        }

        // Mate Distance Pruning (MDP)
        alpha = alpha.max(mated_in(td.ply));
        beta = beta.min(mate_in(td.ply + 1));

        if alpha >= beta {
            return alpha;
        }
    }

    let mut best_score = -Score::INFINITE;
    let mut max_score = Score::INFINITE;

    let mut depth = depth.min(MAX_PLY as i32 - 1);
    let initial_depth = depth;

    let hash = td.board.hash();
    let (entry, tt_slot) = td.tt.read(hash, td.board.halfmove_clock(), td.ply);
    let mut tt_depth = 0;
    let mut tt_move = Move::NULL;
    let mut tt_score = Score::NONE;
    let mut tt_bound = Bound::None;

    let mut tt_pv = NODE::PV;

    // Search Early TT-Cut
    if let Some(entry) = &entry {
        tt_move = entry.mv;
        tt_pv |= entry.pv;
        tt_score = entry.score;
        tt_depth = entry.depth;
        tt_bound = entry.bound;

        if !NODE::PV
            && !excluded
            && tt_depth > depth - (tt_score <= beta) as i32 - (tt_bound == Bound::Exact) as i32
            && is_valid(tt_score)
            && match tt_bound {
                Bound::Upper => tt_score <= alpha && (!cut_node || depth > 5),
                Bound::Lower => tt_score >= beta && (cut_node || depth > 5),
                _ => true,
            }
        {
            if tt_move.is_quiet() && tt_score >= beta {
                let quiet_bonus = (144 * depth - 74).min(1466) + 67 * !cut_node as i32;
                let conthist_bonus = (92 * depth - 61).min(1493) + 65 * !cut_node as i32;

                td.quiet_history.update(td.board.threats(), td.board.side_to_move(), tt_move, quiet_bonus);
                update_continuation_histories(td, td.board.moved_piece(tt_move), tt_move.to(), conthist_bonus);
            }

            if td.board.halfmove_clock() < 90 {
                debug_assert!(is_valid(tt_score));
                return tt_score;
            }
        }
    }

    // Tablebases Probe
    if !NODE::ROOT
        && !excluded
        && td.board.halfmove_clock() == 0
        && td.board.castling().raw() == 0
        && td.board.occupancies().len() <= tb_size()
    {
        if let Some(outcome) = tb_probe(&td.board) {
            td.tb_hits.increment();

            let (score, bound) = match outcome {
                GameOutcome::Win => (tb_win_in(td.ply), Bound::Lower),
                GameOutcome::Loss => (tb_loss_in(td.ply), Bound::Upper),
                GameOutcome::Draw => (Score::DRAW, Bound::Exact),
            };

            if bound == Bound::Exact
                || (bound == Bound::Lower && score >= beta)
                || (bound == Bound::Upper && score <= alpha)
            {
                let depth = (depth + 6).min(MAX_PLY as i32 - 1);
                td.tt.write(tt_slot, hash, depth, Score::NONE, score, bound, Move::NULL, td.ply, tt_pv);
                return score;
            }

            if NODE::PV {
                if bound == Bound::Lower {
                    best_score = score;
                    alpha = alpha.max(best_score);
                } else {
                    max_score = score;
                }
            }
        }
    }

    let correction_value = correction_value(td);

    let raw_eval;
    let static_eval;
    let mut eval;

    // Evaluation
    if in_check {
        raw_eval = Score::NONE;
        static_eval = Score::NONE;
        eval = Score::NONE;
    } else if excluded {
        raw_eval = td.stack[td.ply].static_eval;
        static_eval = raw_eval;
        eval = static_eval;
    } else if let Some(entry) = &entry {
        raw_eval = if is_valid(entry.eval) { entry.eval } else { evaluate(td) };
        static_eval = corrected_eval(raw_eval, correction_value, td.board.halfmove_clock());
        eval = static_eval;

        if is_valid(tt_score)
            && match tt_bound {
                Bound::Upper => tt_score < eval,
                Bound::Lower => tt_score > eval,
                _ => true,
            }
        {
            eval = tt_score;
        }
    } else {
        raw_eval = evaluate(td);
        td.tt.write(tt_slot, hash, TtDepth::SOME, raw_eval, Score::NONE, Bound::None, Move::NULL, td.ply, tt_pv);

        static_eval = corrected_eval(raw_eval, correction_value, td.board.halfmove_clock());
        eval = static_eval;
    }

    td.stack[td.ply].static_eval = static_eval;
    td.stack[td.ply].tt_pv = tt_pv;
    td.stack[td.ply].reduction = 0;
    td.stack[td.ply].move_count = 0;
    td.stack[td.ply + 2].cutoff_count = 0;

    // Quiet Move Ordering Using Static-Eval
    if !NODE::ROOT
        && !in_check
        && !excluded
        && td.stack[td.ply - 1].mv.is_quiet()
        && is_valid(td.stack[td.ply - 1].static_eval)
    {
        let value = 722 * (-(static_eval + td.stack[td.ply - 1].static_eval)) / 128;
        let bonus = value.clamp(-60, 128);

        td.quiet_history.update(td.board.prior_threats(), !td.board.side_to_move(), td.stack[td.ply - 1].mv, bonus);
    }

    // Hindsight reductions
    if !NODE::ROOT
        && !in_check
        && !excluded
        && td.stack[td.ply - 1].reduction >= 2561
        && static_eval + td.stack[td.ply - 1].static_eval < 0
    {
        depth += 1;
    }

    if !NODE::ROOT
        && !tt_pv
        && !in_check
        && !excluded
        && depth >= 2
        && td.stack[td.ply - 1].reduction >= 980
        && is_valid(td.stack[td.ply - 1].static_eval)
        && static_eval + td.stack[td.ply - 1].static_eval > 61
    {
        depth -= 1;
    }

    let potential_singularity =
        depth >= 5 && tt_depth >= depth - 3 && tt_bound != Bound::Upper && is_valid(tt_score) && !is_decisive(tt_score);

    let mut improvement = 0;
    if !in_check && td.ply >= 2 && td.stack[td.ply - 1].mv.is_some() && is_valid(td.stack[td.ply - 2].static_eval) {
        improvement = static_eval - td.stack[td.ply - 2].static_eval;
    }

    let improving = improvement > 0;

    // Razoring
    if !NODE::PV && !in_check && eval < alpha - 305 - 239 * initial_depth * initial_depth {
        return qsearch::<NonPV>(td, alpha, beta);
    }

    if !tt_pv
        && !in_check
        && !excluded
        && eval >= beta
        && !is_loss(beta)
        && !is_win(eval)
        && depth < 6
        && tt_bound != Bound::Upper
    {
        if predict_prob([
            (eval - beta) as f32,
            depth as f32,
            improving as i32 as f32,
            cut_node as i32 as f32,
            correction_value.abs() as f32,
            (tt_depth - depth) as f32,
            (tt_bound == Bound::Lower) as i32 as f32,
            (tt_bound == Bound::Upper) as i32 as f32,
            tt_move.is_quiet() as i32 as f32,
            0.0,
            (static_eval - beta) as i32 as f32,
        ]) >= rfp_threshold_for_depth(depth)
        {
            return (eval + beta) / 2;
        }
    }

    // Null Move Pruning (NMP)
    if cut_node
        && !in_check
        && !excluded
        && eval >= beta
        && eval >= static_eval
        && static_eval >= beta - 15 * depth + 154 * tt_pv as i32 - 104 * improvement / 1024 + 189
        && td.ply as i32 >= td.nmp_min_ply
        && td.board.has_non_pawns()
        && !potential_singularity
        && !is_loss(beta)
    {
        let r = 5 + depth / 3 + ((eval - beta) / 248).min(3);

        td.stack[td.ply].conthist = std::ptr::null_mut();
        td.stack[td.ply].contcorrhist = std::ptr::null_mut();
        td.stack[td.ply].piece = Piece::None;
        td.stack[td.ply].mv = Move::NULL;
        td.ply += 1;

        td.board.make_null_move();

        let score = if (depth - r) <= 0 {
            -qsearch::<NonPV>(td, -beta, -beta + 1)
        } else {
            -search::<NonPV>(td, -beta, -beta + 1, depth - r, false)
        };

        td.board.undo_null_move();
        td.ply -= 1;

        if td.stopped {
            return Score::ZERO;
        }

        if score >= beta && !is_win(score) {
            if td.nmp_min_ply > 0 || depth < 16 {
                return score;
            }

            td.nmp_min_ply = td.ply as i32 + 3 * (depth - r) / 4;
            let verified_score = search::<NonPV>(td, beta - 1, beta, depth - r, false);
            td.nmp_min_ply = 0;

            if td.stopped {
                return Score::ZERO;
            }

            if verified_score >= beta {
                return score;
            }
        }
    }

    // ProbCut
    let probcut_beta = beta + 265 - 60 * improving as i32;

    if depth >= 3 && !is_decisive(beta) && (!is_valid(tt_score) || tt_score >= probcut_beta) && !tt_move.is_quiet() {
        let mut move_picker = MovePicker::new_probcut(probcut_beta - static_eval);

        let probcut_depth = (depth - 4).max(0);

        while let Some(mv) = move_picker.next(td, true) {
            if move_picker.stage() == Stage::BadNoisy {
                break;
            }

            if mv == td.stack[td.ply].excluded || !td.board.is_legal(mv) {
                continue;
            }

            make_move(td, mv);

            let mut score = -qsearch::<NonPV>(td, -probcut_beta, -probcut_beta + 1);

            if score >= probcut_beta && probcut_depth > 0 {
                score = -search::<NonPV>(td, -probcut_beta, -probcut_beta + 1, probcut_depth, !cut_node);
            }

            undo_move(td, mv);

            if td.stopped {
                return Score::ZERO;
            }

            if score >= probcut_beta {
                td.tt.write(tt_slot, hash, probcut_depth + 1, raw_eval, score, Bound::Lower, mv, td.ply, tt_pv);

                if !is_decisive(score) {
                    return score - (probcut_beta - beta);
                }
            }
        }
    }

    // Internal Iterative Reductions (IIR)
    if depth >= 3 + 3 * cut_node as i32 && tt_move.is_null() && (NODE::PV || cut_node) {
        depth -= 1;
    }

    let mut best_move = Move::NULL;
    let mut bound = Bound::Upper;

    let mut quiet_moves = ArrayVec::<Move, 32>::new();
    let mut noisy_moves = ArrayVec::<Move, 32>::new();

    let mut move_count = 0;
    let mut move_picker = MovePicker::new(tt_move);
    let mut skip_quiets = false;

    while let Some(mv) = move_picker.next(td, skip_quiets) {
        if mv == td.stack[td.ply].excluded || !td.board.is_legal(mv) {
            continue;
        }

        move_count += 1;
        td.stack[td.ply].move_count = move_count;

        let is_quiet = mv.is_quiet();

        let history = if is_quiet {
            td.quiet_history.get(td.board.threats(), td.board.side_to_move(), mv)
                + td.conthist(1, mv)
                + td.conthist(2, mv)
        } else {
            let captured = td.board.piece_on(mv.to()).piece_type();
            td.noisy_history.get(td.board.threats(), td.board.moved_piece(mv), mv.to(), captured)
        };

        let mut reduction = td.lmr.reduction(depth, move_count);

        if !improving {
            reduction += (499 - 434 * improvement / 128).min(1263);
        }

        if !NODE::ROOT && !is_loss(best_score) {
            let lmr_reduction = if is_quiet { reduction - 143 * history / 1024 } else { reduction };
            let lmr_depth = (depth - lmr_reduction / 1024).max(0);

            // Late Move Pruning (LMP)
            skip_quiets |= move_count
                >= (4 + initial_depth * initial_depth) / (2 - (improving || static_eval >= beta + 17) as i32);

            // Futility Pruning (FP)
            let futility_value = static_eval + 107 * lmr_depth + 75 + 32 * history / 1024;
            if !in_check
                && is_quiet
                && lmr_depth < 8
                && futility_value <= alpha
                && !td.board.might_give_check_if_you_squint(mv)
            {
                if !is_decisive(best_score) && best_score <= futility_value {
                    best_score = futility_value;
                }
                skip_quiets = true;
                continue;
            }

            // Bad Noisy Futility Pruning (BNFP)
            let noisy_futility_value = static_eval
                + 118 * lmr_depth
                + 360 * move_count / 128
                + 80 * (history + 507) / 1024
                + 91 * PIECE_VALUES[td.board.piece_on(mv.to()).piece_type()] / 1024;

            if !in_check && lmr_depth < 6 && move_picker.stage() == Stage::BadNoisy && noisy_futility_value <= alpha {
                if !is_decisive(best_score) && best_score <= noisy_futility_value {
                    best_score = noisy_futility_value;
                }
                break;
            }

            // Static Exchange Evaluation Pruning (SEE Pruning)
            let threshold = if is_quiet {
                -22 * lmr_depth * lmr_depth - 44 * (history + 19) / 1024
            } else {
                -104 * depth + 46 - 45 * (history + 13) / 1024
            };

            if !td.board.see(mv, threshold) {
                continue;
            }
        }

        // Singular Extensions (SE)
        let mut extension = 0;

        if !NODE::ROOT && !excluded && td.ply < 2 * td.root_depth as usize && mv == tt_move && potential_singularity {
            debug_assert!(is_valid(tt_score));

            let singular_beta = tt_score - depth;
            let singular_depth = (depth - 1) / 2;

            td.stack[td.ply].excluded = tt_move;
            let score = search::<NonPV>(td, singular_beta - 1, singular_beta, singular_depth, cut_node);
            td.stack[td.ply].excluded = Move::NULL;

            if td.stopped {
                return Score::ZERO;
            }

            if score < singular_beta {
                let double_margin = 2 + 277 * NODE::PV as i32;
                let triple_margin = 67 + 315 * NODE::PV as i32 - 16 * correction_value.abs() / 128;

                extension = 1;
                extension += (score < singular_beta - double_margin) as i32;
                extension += (score < singular_beta - triple_margin) as i32;

                if extension > 1 && depth < 14 {
                    depth += 1;
                }
            } else if score >= beta && !is_decisive(score) {
                return score;
            } else if tt_score >= beta {
                extension = -2;
            } else if cut_node {
                extension = -2;
            }
        }

        let initial_nodes = td.nodes.local();

        make_move(td, mv);

        let mut new_depth = depth + extension - 1;
        let mut score = Score::ZERO;

        // Late Move Reductions (LMR)
        if depth >= 2 && move_count > 1 + NODE::ROOT as i32 {
            if is_quiet {
                reduction -= 139 * (history - 763) / 1024;
            } else {
                reduction -= 107 * (history - 547) / 1024;
                reduction -= 43 * PIECE_VALUES[td.board.piece_on(mv.to()).piece_type()] / 120;
            }

            reduction -= 3689 * correction_value.abs() / 1024;
            reduction -= 71 * move_count;
            reduction += 420;

            if tt_pv {
                reduction -= 454;
                reduction -= 680 * (is_valid(tt_score) && tt_score > alpha) as i32;
                reduction -= 817 * (is_valid(tt_score) && tt_depth >= depth) as i32;
                reduction -= 902 * cut_node as i32;
            }

            if NODE::PV {
                reduction -= 416 + 549 * (beta - alpha > 33 * td.root_delta / 128) as i32;
            }

            if cut_node {
                reduction += 1766;
                reduction += 980 * tt_move.is_null() as i32;
            }

            if td.board.in_check() || !td.board.has_non_pawns() {
                reduction -= 1026;
            }

            if td.stack[td.ply].cutoff_count > 2 {
                reduction += 1639;
            }

            if is_valid(tt_score) && tt_score < alpha && tt_bound == Bound::Upper {
                reduction += 801;
            }

            if depth == 2 {
                reduction -= 1331;
            }

            let reduced_depth = (new_depth - reduction / 1024)
                .clamp(NODE::PV as i32, new_depth + cut_node as i32 + NODE::PV as i32)
                + NODE::PV as i32;

            td.stack[td.ply - 1].reduction = reduction;
            score = -search::<NonPV>(td, -alpha - 1, -alpha, reduced_depth, true);
            td.stack[td.ply - 1].reduction = 0;

            if score > alpha && new_depth > reduced_depth {
                new_depth += (score > best_score + 38 + 437 * depth / 111) as i32;
                new_depth -= (score < best_score + new_depth) as i32;

                if new_depth > reduced_depth {
                    score = -search::<NonPV>(td, -alpha - 1, -alpha, new_depth, !cut_node);

                    if mv.is_quiet() && score >= beta {
                        let bonus = (1 + 2 * (move_count > depth) as i32 + 2 * (move_count > 2 * depth) as i32)
                            * (159 * depth - 62).min(866);
                        td.ply -= 1;
                        update_continuation_histories(td, td.stack[td.ply].piece, mv.to(), bonus);
                        td.ply += 1;
                    }
                }
            } else if score > alpha && score < best_score + 15 {
                new_depth -= 1;
            }
        }
        // Full Depth Search (FDS)
        else if !NODE::PV || move_count > 1 {
            reduction -= 2806 * correction_value.abs() / 1024;
            reduction -= 51 * move_count;
            reduction += 314;

            if tt_pv {
                reduction -= 776;
                reduction -= 536 * (is_valid(tt_score) && tt_score > alpha) as i32;
                reduction -= 1071 * (is_valid(tt_score) && tt_depth >= depth) as i32;
                reduction -= 1141 * cut_node as i32;
            }

            if NODE::PV {
                reduction -= 480 + 801 * (beta - alpha > 26 * td.root_delta / 128) as i32;
            }

            if cut_node {
                reduction += 1391;
                reduction += 1055 * tt_move.is_null() as i32;
            }

            if td.board.in_check() || !td.board.has_non_pawns() {
                reduction -= 741;
            }

            if td.stack[td.ply].cutoff_count > 2 {
                reduction += 1477;
            }

            if is_valid(tt_score) && tt_score < alpha && tt_bound == Bound::Upper {
                reduction += 854;
            }

            if depth == 2 {
                reduction -= 1086;
            }

            if mv == tt_move {
                reduction = -1887;
            }

            if is_quiet {
                reduction -= 143 * (history - 556) / 1024;
            } else {
                reduction -= 67 * (history - 551) / 1024;
                reduction -= 45 * PIECE_VALUES[td.board.piece_on(mv.to()).piece_type()] / 132;
            }

            td.stack[td.ply - 1].reduction = 1024 * ((initial_depth - 1) - new_depth);
            score = -search::<NonPV>(td, -alpha - 1, -alpha, new_depth - (reduction > 3000) as i32, !cut_node);
            td.stack[td.ply - 1].reduction = 0;
        }

        // Principal Variation Search (PVS)
        if NODE::PV && (move_count == 1 || score > alpha) {
            score = -search::<PV>(td, -beta, -alpha, new_depth, false);
        }

        undo_move(td, mv);

        if td.stopped {
            return Score::ZERO;
        }

        if NODE::ROOT {
            let root_move = td.root_moves.iter_mut().find(|v| v.mv == mv).unwrap();

            root_move.nodes += td.nodes.local() - initial_nodes;

            if move_count == 1 || score > alpha {
                match score {
                    v if v <= alpha => {
                        root_move.display_score = alpha;
                        root_move.upperbound = true;
                    }
                    v if v >= beta => {
                        root_move.display_score = beta;
                        root_move.lowerbound = true;
                    }
                    _ => {
                        root_move.display_score = score;
                        root_move.upperbound = false;
                        root_move.lowerbound = false;
                    }
                }

                root_move.score = score;
                root_move.sel_depth = td.sel_depth;
            } else {
                root_move.score = -Score::INFINITE;
            }
        }

        if score > best_score {
            best_score = score;

            if score > alpha {
                bound = Bound::Exact;
                alpha = score;
                best_move = mv;

                if NODE::PV {
                    td.pv.update(td.ply, mv);
                }

                if score >= beta {
                    bound = Bound::Lower;
                    td.stack[td.ply].cutoff_count += 1;
                    break;
                }

                if depth > 2 && depth < 17 && !is_decisive(score) {
                    depth -= 1;
                }
            }
        }

        if mv != best_move && move_count < 32 {
            if mv.is_noisy() {
                noisy_moves.push(mv);
            } else {
                quiet_moves.push(mv);
            }
        }
    }

    if move_count == 0 {
        if excluded {
            return alpha;
        }

        return if in_check { mated_in(td.ply) } else { Score::DRAW };
    }

    if best_move.is_some() {
        let bonus_noisy = (128 * depth - 54).min(1136) - 69 * cut_node as i32;
        let malus_noisy = (150 * initial_depth - 64).min(1459) - 24 * noisy_moves.len() as i32;

        let bonus_quiet = (152 * depth - 69).min(1624) - 64 * cut_node as i32;
        let malus_quiet =
            (133 * initial_depth - 57).min(1122) - 36 * quiet_moves.len() as i32 + 190 * skip_quiets as i32;

        let bonus_cont = (99 * depth - 56).min(1265) - 68 * cut_node as i32;
        let malus_cont =
            (289 * initial_depth - 53).min(1032) - 30 * quiet_moves.len() as i32 + 126 * skip_quiets as i32;

        if best_move.is_noisy() {
            td.noisy_history.update(
                td.board.threats(),
                td.board.moved_piece(best_move),
                best_move.to(),
                td.board.piece_on(best_move.to()).piece_type(),
                bonus_noisy,
            );
        } else if !quiet_moves.is_empty() || depth > 3 {
            td.quiet_history.update(td.board.threats(), td.board.side_to_move(), best_move, bonus_quiet);
            update_continuation_histories(td, td.board.moved_piece(best_move), best_move.to(), bonus_cont);

            for &mv in quiet_moves.iter() {
                td.quiet_history.update(td.board.threats(), td.board.side_to_move(), mv, -malus_quiet);
                update_continuation_histories(td, td.board.moved_piece(mv), mv.to(), -malus_cont);
            }
        }

        for &mv in noisy_moves.iter() {
            let captured = td.board.piece_on(mv.to()).piece_type();
            td.noisy_history.update(td.board.threats(), td.board.moved_piece(mv), mv.to(), captured, -malus_noisy);
        }

        if !NODE::ROOT && td.stack[td.ply - 1].mv.is_quiet() && td.stack[td.ply - 1].move_count == 1 {
            let malus = (82 * initial_depth - 53).min(845);

            td.ply -= 1;
            update_continuation_histories(td, td.stack[td.ply].piece, td.stack[td.ply].mv.to(), -malus);
            td.ply += 1;
        }
    }

    if !NODE::ROOT && bound == Bound::Upper && (!quiet_moves.is_empty() || depth > 3) {
        tt_pv |= td.stack[td.ply - 1].tt_pv;

        let pcm_move = td.stack[td.ply - 1].mv;
        if pcm_move.is_quiet() {
            let mut factor = 106;
            factor += 148 * (initial_depth > 5) as i32;
            factor += 237 * (!in_check && best_score <= static_eval.min(raw_eval) - 133) as i32;
            factor += 291
                * (is_valid(td.stack[td.ply - 1].static_eval) && best_score <= -td.stack[td.ply - 1].static_eval - 102)
                    as i32;

            let scaled_bonus = factor * (151 * initial_depth - 42).min(1770) / 128;

            td.quiet_history.update(td.board.prior_threats(), !td.board.side_to_move(), pcm_move, scaled_bonus);

            if td.ply >= 2 {
                let entry = &td.stack[td.ply - 2];
                if entry.mv.is_some() {
                    let bonus = (158 * initial_depth - 43).min(1589);
                    td.continuation_history.update(entry.conthist, td.stack[td.ply - 1].piece, pcm_move.to(), bonus);
                }
            }
        }
    }

    if best_score >= beta && !is_decisive(best_score) && !is_decisive(beta) {
        best_score = (best_score * depth + beta) / (depth + 1);
    }

    if NODE::PV {
        best_score = best_score.min(max_score);
    }

    if !excluded {
        td.tt.write(tt_slot, hash, depth, raw_eval, best_score, bound, best_move, td.ply, tt_pv);
    }

    if !(in_check
        || best_move.is_noisy()
        || (bound == Bound::Upper && best_score >= static_eval)
        || (bound == Bound::Lower && best_score <= static_eval))
    {
        update_correction_histories(td, depth, best_score - static_eval);
    }

    debug_assert!(-Score::INFINITE < best_score && best_score < Score::INFINITE);

    best_score
}

fn qsearch<NODE: NodeType>(td: &mut ThreadData, mut alpha: i32, beta: i32) -> i32 {
    debug_assert!(td.ply <= MAX_PLY);
    debug_assert!(-Score::INFINITE <= alpha && alpha < beta && beta <= Score::INFINITE);

    if alpha < Score::ZERO && td.board.upcoming_repetition(td.ply) {
        alpha = Score::ZERO;
        if alpha >= beta {
            return alpha;
        }
    }

    let in_check = td.board.in_check();

    if NODE::PV {
        td.pv.clear(td.ply);
        td.sel_depth = td.sel_depth.max(td.ply as i32);
    }

    if td.time_manager.check_time(td) {
        td.stopped = true;
        return Score::ZERO;
    }

    if td.board.is_draw(td.ply) {
        return Score::DRAW;
    }

    if td.ply >= MAX_PLY - 1 {
        return if in_check { Score::DRAW } else { evaluate(td) };
    }

    let hash = td.board.hash();
    let (entry, tt_slot) = td.tt.read(hash, td.board.halfmove_clock(), td.ply);
    let mut tt_pv = NODE::PV;
    let mut tt_score = Score::NONE;
    let mut tt_bound = Bound::None;

    // QS Early TT-Cut
    if let Some(entry) = &entry {
        tt_pv |= entry.pv;
        tt_score = entry.score;
        tt_bound = entry.bound;

        if is_valid(tt_score)
            && match tt_bound {
                Bound::Upper => tt_score <= alpha,
                Bound::Lower => tt_score >= beta,
                _ => true,
            }
            && (!NODE::PV || !is_decisive(tt_score))
        {
            return tt_score;
        }
    }

    let mut best_score = -Score::INFINITE;
    let mut futility_score = Score::NONE;
    let mut raw_eval = Score::NONE;

    // Evaluation
    if !in_check {
        raw_eval = match &entry {
            Some(entry) if is_valid(entry.eval) => entry.eval,
            _ => evaluate(td),
        };

        let static_eval = corrected_eval(raw_eval, correction_value(td), td.board.halfmove_clock());
        best_score = static_eval;

        if is_valid(tt_score)
            && match tt_bound {
                Bound::Upper => tt_score < static_eval,
                Bound::Lower => tt_score > static_eval,
                _ => true,
            }
        {
            best_score = tt_score;
        }

        if best_score >= beta {
            if !is_decisive(best_score) && !is_decisive(beta) {
                best_score = (best_score + beta) / 2;
            }

            if entry.is_none() {
                td.tt.write(
                    tt_slot,
                    hash,
                    TtDepth::SOME,
                    raw_eval,
                    best_score,
                    Bound::Lower,
                    Move::NULL,
                    td.ply,
                    tt_pv,
                );
            }

            return best_score;
        }

        if best_score > alpha {
            alpha = best_score;
        }

        futility_score = static_eval + 129;
    }

    let mut best_move = Move::NULL;

    let mut move_count = 0;
    let mut move_picker = MovePicker::new_qsearch();

    let previous_square = match td.stack[td.ply - 1].mv {
        Move::NULL => Square::None,
        _ => td.stack[td.ply - 1].mv.to(),
    };

    while let Some(mv) = move_picker.next(td, !in_check) {
        if !td.board.is_legal(mv) {
            continue;
        }

        move_count += 1;

        if !is_loss(best_score) && mv.to() != previous_square {
            if move_picker.stage() == Stage::BadNoisy {
                break;
            }

            if move_count >= 3 {
                break;
            }

            if in_check && mv.is_quiet() {
                break;
            }

            if !in_check && futility_score <= alpha && !td.board.see(mv, 1) {
                best_score = best_score.max(futility_score);
                continue;
            }
        }

        if !is_loss(best_score) && !td.board.see(mv, -79) {
            continue;
        }

        make_move(td, mv);

        let score = -qsearch::<NODE>(td, -beta, -alpha);

        undo_move(td, mv);

        if td.stopped {
            return Score::ZERO;
        }

        if score > best_score {
            best_score = score;

            if score > alpha {
                best_move = mv;
                alpha = score;

                if NODE::PV {
                    td.pv.update(td.ply, mv);
                }

                if score >= beta {
                    break;
                }
            }
        }
    }

    if in_check && move_count == 0 {
        return mated_in(td.ply);
    }

    if best_score >= beta && !is_decisive(best_score) && !is_decisive(beta) {
        best_score = (best_score + beta) / 2;
    }

    let bound = if best_score >= beta { Bound::Lower } else { Bound::Upper };

    td.tt.write(tt_slot, hash, TtDepth::SOME, raw_eval, best_score, bound, best_move, td.ply, tt_pv);

    debug_assert!(-Score::INFINITE < best_score && best_score < Score::INFINITE);

    best_score
}

fn correction_value(td: &ThreadData) -> i32 {
    let stm = td.board.side_to_move();

    let mut correction = td.pawn_corrhist.get(stm, td.board.pawn_key())
        + td.minor_corrhist.get(stm, td.board.minor_key())
        + td.major_corrhist.get(stm, td.board.major_key())
        + td.non_pawn_corrhist[Color::White].get(stm, td.board.non_pawn_key(Color::White))
        + td.non_pawn_corrhist[Color::Black].get(stm, td.board.non_pawn_key(Color::Black));

    if td.ply >= 2 && td.stack[td.ply - 1].mv.is_some() && td.stack[td.ply - 2].mv.is_some() {
        correction += td.continuation_corrhist.get(
            td.stack[td.ply - 2].contcorrhist,
            td.stack[td.ply - 1].piece,
            td.stack[td.ply - 1].mv.to(),
        );
    }

    correction
}

fn corrected_eval(eval: i32, correction_value: i32, hmr: u8) -> i32 {
    (eval * (200 - hmr as i32) / 200 + correction_value).clamp(-Score::TB_WIN_IN_MAX + 1, Score::TB_WIN_IN_MAX - 1)
}

fn update_correction_histories(td: &mut ThreadData, depth: i32, diff: i32) {
    let stm = td.board.side_to_move();
    let bonus = (141 * depth * diff / 128).clamp(-4038, 3244);

    td.pawn_corrhist.update(stm, td.board.pawn_key(), bonus);
    td.minor_corrhist.update(stm, td.board.minor_key(), bonus);
    td.major_corrhist.update(stm, td.board.major_key(), bonus);

    td.non_pawn_corrhist[Color::White].update(stm, td.board.non_pawn_key(Color::White), bonus);
    td.non_pawn_corrhist[Color::Black].update(stm, td.board.non_pawn_key(Color::Black), bonus);

    if td.ply >= 2 && td.stack[td.ply - 1].mv.is_some() && td.stack[td.ply - 2].mv.is_some() {
        td.continuation_corrhist.update(
            td.stack[td.ply - 2].contcorrhist,
            td.stack[td.ply - 1].piece,
            td.stack[td.ply - 1].mv.to(),
            bonus,
        );
    }
}

fn update_continuation_histories(td: &mut ThreadData, piece: Piece, sq: Square, bonus: i32) {
    for offset in [1, 2, 3, 4, 6] {
        if td.ply >= offset {
            let entry = &td.stack[td.ply - offset];
            if entry.mv.is_some() {
                td.continuation_history.update(entry.conthist, piece, sq, bonus);
            }
        }
    }
}

fn make_move(td: &mut ThreadData, mv: Move) {
    td.stack[td.ply].mv = mv;
    td.stack[td.ply].piece = td.board.moved_piece(mv);
    td.stack[td.ply].conthist =
        td.continuation_history.subtable_ptr(td.board.in_check(), mv.is_noisy(), td.board.moved_piece(mv), mv.to());
    td.stack[td.ply].contcorrhist =
        td.continuation_corrhist.subtable_ptr(td.board.in_check(), mv.is_noisy(), td.board.moved_piece(mv), mv.to());
    td.ply += 1;

    td.nodes.increment();
    td.nnue.push(mv, &td.board);
    td.board.make_move(mv);
    td.tt.prefetch(td.board.hash());
}

fn undo_move(td: &mut ThreadData, mv: Move) {
    td.ply -= 1;
    td.nnue.pop();
    td.board.undo_move(mv);
}
